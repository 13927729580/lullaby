"""Generates the Lullaby entity flatbuffer schema."""

load(":utils_common.bzl",
     "FLATC_DEFAULT_ARGS",
     "FLATC_DEFAULT_INCLUDES",
     "FLATC_DEFAULT_INCLUDE_PATHS",
     "FLATC_JS_DEFAULT_ARGS")

def generate_entity_schema(
    src,
    schema_name,
    library_name,
    includes = [],
    include_paths = [],
    js_library_name = "",
    identifier = "ENTS",
    visibility = None):
  """Generates the Lullaby entity flatbuffer schema.

  The generated schema extends a client-provided .fbs containing a
  'ComponentDef' flatbuffer union with Lullaby-specific 'EntityDef' table.
  See scripts/generate_entity_schema.py for more details.

  Args:
    src: name for the fbs file containing the ComponentDef union.
    schema_name: name for the filegroup containing the generated entity.fbs
                 schema file
    library_name: name for the cc_library containing entity_generated.h
                  generated by flatc using the generated entity.fbs
    includes: Optional, list of filegroups of schemas that the srcs depend on.
    include_paths: Optional, list of paths the includes files can be found in.
    js_library_name: name for the js_library containing entity_generated.js
                     generated by flatc using the generated entity.fbs
    identifier: file_identifier for the flatbuffer type.  Only set if using
                more than one entity schema in your app.
    visibility: Optional, the visibility of the resulting flatbuffer library.
  """
  flatc = "@flatbuffers//:flatc"
  script = "//lullaby/tools:generate_entity_schema"
  template = "//lullaby/tools:entity_schema.template"

  # Step 1. Generate a "complete" entity.fbs file.
  generated_src = "generated/%s" % src
  native.genrule(name="%s_generated" % schema_name,
                 tools=[script],
                 srcs=[template, src],
                 outs=[generated_src],
                 cmd=" ".join([
                     "$(location %s)" % script,
                     "-i $(location %s)" % src,
                     "-x $(location %s)" % template,
                     "-o $(location %s)" % generated_src,
                     "--identifier %s" % identifier
                 ]))

  full_includes = list(depset(FLATC_DEFAULT_INCLUDES + includes))
  full_include_paths = list(depset(FLATC_DEFAULT_INCLUDE_PATHS + include_paths))
  include_paths_cmd = ["-I %s" % (s) for s in full_include_paths]
  library_srcs = "%s_srcs" % (library_name)
  generated_hdr = "%s_generated.h" % (generated_src.replace(".fbs", "").split("/")[-1])

  # Step 2. Generate a header file from the entity.fbs file.
  native.genrule(
      name=library_srcs,
      srcs=[generated_src] + full_includes,
      outs=[generated_hdr],
      tools=[flatc],
      cmd=" ".join([
          "$(location %s)" % (flatc),
          " ".join(include_paths_cmd),
          " ".join(FLATC_DEFAULT_ARGS),
          "-c",
          "-o $(@D)",
          "$(location %s)" % (generated_src),
      ]),
      message="Generating flatbuffer files for %s:" % (library_name),
  )

  # Step 3. Generate the cc_library from the generated header file.
  native.cc_library(
      name = library_name,
      hdrs = [
        ":" + library_srcs
      ],
      srcs = [
        ":" + library_srcs
      ],
      features = [
          "-parse_headers",
      ],
      deps = [
          "@flatbuffers//:flatbuffers",
      ],
      includes = [".", "lullaby/generated"],
      linkstatic = 1,
      visibility = visibility)

  # Step 4. Generate a filegroup from the generated header file.
  native.filegroup(
      name = schema_name,
      srcs = [generated_src],
      visibility = ["//visibility:public"])

  # Step 5. Generate a filegroup for all the include files used to generate this
  # schema.
  native.filegroup(
      name = "%s_includes" % (schema_name),
      srcs = full_includes,
      visibility = ["//visibility:public"])
