// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RIGIDBODYDEF__H_
#define FLATBUFFERS_GENERATED_RIGIDBODYDEF__H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"
#include "physics_shapes_generated.h"

namespace lull {

struct RigidBodyDef;

/// Defines how a physics simulation should treat this rigid body.
enum RigidBodyType {
  /// A standard rigid body (i.e. a pool ball or tumbling block).
  RigidBodyType_Dynamic = 0  /// A completely immovable object (i.e. a floor).
  /// Note that Static rigid bodies will not produce contact events with other
  /// Static and Kinematic rigid bodies.
  /// TODO(b/63851094): mention ghost objects as a way of solving this.
,
  RigidBodyType_Static = 1  /// A non-physics object that can move (i.e. an anchored moving platform). A
  /// Kinematic body will not have its transforms simulated, but will have its
  /// transform updated prior to each simulation update based on the
  /// TransformSystem.
  /// Note that Kinematic rigid bodies will not produce contact events with
  /// other Static and Kinematic rigid bodies.
  /// TODO(b/63851094): mention ghost objects as a way of solving this.
,
  RigidBodyType_Kinematic = 2,
  RigidBodyType_MIN = RigidBodyType_Dynamic,
  RigidBodyType_MAX = RigidBodyType_Kinematic
};

inline RigidBodyType (&EnumValuesRigidBodyType())[3] {
  static RigidBodyType values[] = {
    RigidBodyType_Dynamic,
    RigidBodyType_Static,
    RigidBodyType_Kinematic
  };
  return values;
}

inline const char **EnumNamesRigidBodyType() {
  static const char *names[] = {
    "Dynamic",
    "Static",
    "Kinematic",
    nullptr
  };
  return names;
}

inline const char *EnumNameRigidBodyType(RigidBodyType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRigidBodyType()[index];
}

/// Describes the rigid body properties of an Entity for the physics simulation.
struct RigidBodyDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.RigidBodyDef";
  }
  enum {
    VT_TYPE = 4,
    VT_SHAPES = 6,
    VT_MASS = 8,
    VT_FRICTION = 10,
    VT_RESTITUTION = 12,
    VT_ENABLE_ON_CREATE = 14,
    VT_LINEAR_VELOCITY = 16,
    VT_ANGULAR_VELOCITY = 18,
    VT_CENTER_OF_MASS_TRANSLATION = 20
  };
  /// How the body should be simulated.
  RigidBodyType type() const {
    return static_cast<RigidBodyType>(GetField<int32_t>(VT_TYPE, 0));
  }
  /// The list of shapes for this body.
  /// TODO(b/64477700): add something about an empty / absent shape using the
  /// Entity's AABB.
  const flatbuffers::Vector<flatbuffers::Offset<lull::PhysicsShapePart>> *shapes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<lull::PhysicsShapePart>> *>(VT_SHAPES);
  }
  /// The mass of the physics object in kg. If the body is Static, this will
  /// automatically be assigned a value of 0.
  float mass() const {
    return GetField<float>(VT_MASS, 0.0f);
  }
  /// The frictional coefficient of the physics object. When two objects
  /// collide, the "total coefficient of friction" determines how much energy is
  /// lost due to friction. This value is per pair of materials, but in the
  /// simulation, it will be computed based on the individual coefficients. A
  /// reasonable range is [0, 1.1], with 0 being no friction at all and 1.1
  /// being the roughest surfaces. Most objects should fall in the range
  /// [0.5, 0.8].
  float friction() const {
    return GetField<float>(VT_FRICTION, 0.5f);
  }
  /// The restitution coefficient of the physics object. When two objects
  /// collide, the "total coefficient of restitution" determines how much
  /// kinetic energy is conserved. This value should be [0, 1], with 0 being
  /// nearly no "bounce", i.e. dropping a brick, and 1 being a nearly perfect
  /// "bounce", i.e. dropping a rubber ball.
  float restitution() const {
    return GetField<float>(VT_RESTITUTION, 0.0f);
  }
  /// Whether or not to enable simulation of this rigid body on create.
  bool enable_on_create() const {
    return GetField<uint8_t>(VT_ENABLE_ON_CREATE, 1) != 0;
  }
  /// The initial linear velocity for this rigid body.
  const lull::Vec3 *linear_velocity() const {
    return GetStruct<const lull::Vec3 *>(VT_LINEAR_VELOCITY);
  }
  /// The initial angular velocity for this rigid body (in Euler angles).
  const lull::Vec3 *angular_velocity() const {
    return GetStruct<const lull::Vec3 *>(VT_ANGULAR_VELOCITY);
  }
  /// A translation to be applied to this rigid body's center of mass before
  /// pushing its transform into the physics simulation. The translation will
  /// be un-applied when pulling the transform from the simulation. Applied in
  /// local space.
  /// For example, if you made an Entity representing a character and wanted its
  /// position to be at its "feet", you could give it a 0.5 radius collision
  /// sphere and a center_of_mass_translation of (0, 0.5, 0).
  const lull::Vec3 *center_of_mass_translation() const {
    return GetStruct<const lull::Vec3 *>(VT_CENTER_OF_MASS_TRANSLATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SHAPES) &&
           verifier.Verify(shapes()) &&
           verifier.VerifyVectorOfTables(shapes()) &&
           VerifyField<float>(verifier, VT_MASS) &&
           VerifyField<float>(verifier, VT_FRICTION) &&
           VerifyField<float>(verifier, VT_RESTITUTION) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ON_CREATE) &&
           VerifyField<lull::Vec3>(verifier, VT_LINEAR_VELOCITY) &&
           VerifyField<lull::Vec3>(verifier, VT_ANGULAR_VELOCITY) &&
           VerifyField<lull::Vec3>(verifier, VT_CENTER_OF_MASS_TRANSLATION) &&
           verifier.EndTable();
  }
};

struct RigidBodyDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(RigidBodyType type) {
    fbb_.AddElement<int32_t>(RigidBodyDef::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_shapes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<lull::PhysicsShapePart>>> shapes) {
    fbb_.AddOffset(RigidBodyDef::VT_SHAPES, shapes);
  }
  void add_mass(float mass) {
    fbb_.AddElement<float>(RigidBodyDef::VT_MASS, mass, 0.0f);
  }
  void add_friction(float friction) {
    fbb_.AddElement<float>(RigidBodyDef::VT_FRICTION, friction, 0.5f);
  }
  void add_restitution(float restitution) {
    fbb_.AddElement<float>(RigidBodyDef::VT_RESTITUTION, restitution, 0.0f);
  }
  void add_enable_on_create(bool enable_on_create) {
    fbb_.AddElement<uint8_t>(RigidBodyDef::VT_ENABLE_ON_CREATE, static_cast<uint8_t>(enable_on_create), 1);
  }
  void add_linear_velocity(const lull::Vec3 *linear_velocity) {
    fbb_.AddStruct(RigidBodyDef::VT_LINEAR_VELOCITY, linear_velocity);
  }
  void add_angular_velocity(const lull::Vec3 *angular_velocity) {
    fbb_.AddStruct(RigidBodyDef::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_center_of_mass_translation(const lull::Vec3 *center_of_mass_translation) {
    fbb_.AddStruct(RigidBodyDef::VT_CENTER_OF_MASS_TRANSLATION, center_of_mass_translation);
  }
  RigidBodyDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RigidBodyDefBuilder &operator=(const RigidBodyDefBuilder &);
  flatbuffers::Offset<RigidBodyDef> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<RigidBodyDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<RigidBodyDef> CreateRigidBodyDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    RigidBodyType type = RigidBodyType_Dynamic,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<lull::PhysicsShapePart>>> shapes = 0,
    float mass = 0.0f,
    float friction = 0.5f,
    float restitution = 0.0f,
    bool enable_on_create = true,
    const lull::Vec3 *linear_velocity = 0,
    const lull::Vec3 *angular_velocity = 0,
    const lull::Vec3 *center_of_mass_translation = 0) {
  RigidBodyDefBuilder builder_(_fbb);
  builder_.add_center_of_mass_translation(center_of_mass_translation);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_linear_velocity(linear_velocity);
  builder_.add_restitution(restitution);
  builder_.add_friction(friction);
  builder_.add_mass(mass);
  builder_.add_shapes(shapes);
  builder_.add_type(type);
  builder_.add_enable_on_create(enable_on_create);
  return builder_.Finish();
}

inline flatbuffers::Offset<RigidBodyDef> CreateRigidBodyDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RigidBodyType type = RigidBodyType_Dynamic,
    const std::vector<flatbuffers::Offset<lull::PhysicsShapePart>> *shapes = nullptr,
    float mass = 0.0f,
    float friction = 0.5f,
    float restitution = 0.0f,
    bool enable_on_create = true,
    const lull::Vec3 *linear_velocity = 0,
    const lull::Vec3 *angular_velocity = 0,
    const lull::Vec3 *center_of_mass_translation = 0) {
  return lull::CreateRigidBodyDef(
      _fbb,
      type,
      shapes ? _fbb.CreateVector<flatbuffers::Offset<lull::PhysicsShapePart>>(*shapes) : 0,
      mass,
      friction,
      restitution,
      enable_on_create,
      linear_velocity,
      angular_velocity,
      center_of_mass_translation);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_RIGIDBODYDEF__H_
